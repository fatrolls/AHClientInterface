/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

struct _IMAGE_SECTION_HEADER *__cdecl GetEnclosingSectionHeader(unsigned int, struct _IMAGE_NT_HEADERS *); // idb
struct _IMAGE_SECTION_HEADER *__cdecl GetPtrFromRVA(unsigned int a1, struct _IMAGE_NT_HEADERS *a2, unsigned __int8 *a3);
void __cdecl DisplayErrorText(DWORD dwMessageId); // idb
struct _IMAGE_DOS_HEADER *__cdecl GetProcAddressDirectlyEx(struct _IMAGE_DOS_HEADER *a1, char *a2, int *a3);
struct _IMAGE_DOS_HEADER *__cdecl GetProcAddressDirectly(struct _IMAGE_DOS_HEADER *a1, char *a2);
int __cdecl LoadPbDllFromMemory(void *lp, void **a2);
BOOL __cdecl UnloadPbDllFromMemory(struct _IMAGE_DOS_HEADER *lpAddress);
unsigned int __cdecl MakeAHPe(void *lp, char *, int *); // idb
int __cdecl LoadAHPe(void *a1, void **a2, struct AHPE_ExportFunction_T *a3);
BOOL __cdecl UnloadAHPe(void *lpAddress);
unsigned int __cdecl ReadFileToBuff(LPCSTR lpFileName, void **); // idb
BOOL __cdecl IsNT();
unsigned int __cdecl AHPeEncryptStr(char *); // idb
unsigned int __cdecl AHPeDecryptStr(char *); // idb
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// HMODULE __stdcall LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// BOOL __stdcall IsBadReadPtr(const void *lp, UINT_PTR ucb);
// int __cdecl rand();
// void __cdecl srand(unsigned int Seed);
// __time32_t __cdecl time(__time32_t *const Time);
// void __cdecl operator delete(void *); idb
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// void *__cdecl operator new(unsigned int); idb
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall GetVersion();


//----- (00000004) --------------------------------------------------------
struct _IMAGE_SECTION_HEADER *__cdecl GetEnclosingSectionHeader(unsigned int a1, struct _IMAGE_NT_HEADERS *a2)
{
  unsigned int v2; // esi
  unsigned int v3; // edi
  struct _IMAGE_SECTION_HEADER *result; // eax
  DWORD v5; // ecx
  unsigned int v6; // edx

  v2 = a2->FileHeader.NumberOfSections;
  v3 = 0;
  result = (struct _IMAGE_SECTION_HEADER *)((char *)&a2->OptionalHeader + a2->FileHeader.SizeOfOptionalHeader);
  if ( !(_WORD)v2 )
    return 0;
  while ( 1 )
  {
    v5 = result->Misc.PhysicalAddress;
    if ( !v5 )
      v5 = result->SizeOfRawData;
    v6 = result->VirtualAddress;
    if ( a1 >= v6 && a1 < v5 + v6 )
      break;
    ++v3;
    ++result;
    if ( v3 >= v2 )
      return 0;
  }
  return result;
}

//----- (00000054) --------------------------------------------------------
struct _IMAGE_SECTION_HEADER *__cdecl GetPtrFromRVA(unsigned int a1, struct _IMAGE_NT_HEADERS *a2, unsigned __int8 *a3)
{
  struct _IMAGE_SECTION_HEADER *result; // eax

  result = GetEnclosingSectionHeader(a1, a2);
  if ( result )
    result = (struct _IMAGE_SECTION_HEADER *)&a3[a1 + result->PointerToRawData - result->VirtualAddress];
  return result;
}

//----- (00000084) --------------------------------------------------------
void __cdecl DisplayErrorText(DWORD dwMessageId)
{
  DWORD v1; // ebx
  HMODULE v2; // esi
  DWORD v3; // edi

  v1 = dwMessageId;
  v2 = 0;
  v3 = 4864;
  if ( dwMessageId >= 0x834 && dwMessageId <= 0xBB7 )
  {
    v2 = LoadLibraryExA("netmsg.dll", 0, 2u);
    if ( v2 )
      v3 = 6912;
  }
  if ( FormatMessageA(v3, v2, v1, 0x400u, (LPSTR)&dwMessageId, 0, 0) )
  {
    MessageBoxA(0, (LPCSTR)dwMessageId, 0, 0);
    LocalFree((HLOCAL)dwMessageId);
  }
  if ( v2 )
    FreeLibrary(v2);
}

//----- (00000110) --------------------------------------------------------
struct _IMAGE_DOS_HEADER *__cdecl GetProcAddressDirectlyEx(struct _IMAGE_DOS_HEADER *a1, char *a2, int *a3)
{
  struct _IMAGE_DOS_HEADER *v3; // ebx
  struct _IMAGE_DOS_HEADER *result; // eax
  struct _IMAGE_NT_HEADERS *v5; // esi
  unsigned int v6; // edi
  DWORD v7; // ebp
  int v8; // ecx
  int v9; // esi
  int v10; // edi
  _DWORD *v11; // ebp
  char *v12; // ecx
  char *v13; // esi
  _DWORD *v14; // edi
  unsigned int v15; // eax
  unsigned int v16; // edx
  _DWORD *v17; // edi
  char *v18; // ecx
  unsigned int v19; // eax
  _DWORD *i; // edx
  unsigned __int16 *v21; // [esp+10h] [ebp-18h]
  unsigned int v22; // [esp+14h] [ebp-14h]
  int v23; // [esp+18h] [ebp-10h]
  char *v24; // [esp+1Ch] [ebp-Ch]
  char *v25; // [esp+20h] [ebp-8h]
  _DWORD *v26; // [esp+24h] [ebp-4h]

  v3 = a1;
  *a3 = 0;
  if ( a1->e_magic != 23117 )
  {
    *a3 = 1;
    return 0;
  }
  v5 = (struct _IMAGE_NT_HEADERS *)((char *)a1 + a1->e_lfanew);
  if ( v5->Signature != 17744 )
  {
    *a3 = 2;
    return 0;
  }
  if ( v5->FileHeader.SizeOfOptionalHeader == 224 && v5->OptionalHeader.Magic == 267 )
  {
    v6 = v5->OptionalHeader.DataDirectory[0].VirtualAddress;
    result = (struct _IMAGE_DOS_HEADER *)GetEnclosingSectionHeader(
                                           v6,
                                           (struct _IMAGE_NT_HEADERS *)((char *)a1 + a1->e_lfanew));
    if ( !result )
    {
      *a3 = 4;
      return result;
    }
    GetPtrFromRVA(v6, v5, (unsigned __int8 *)a1);
    v7 = v5->OptionalHeader.DataDirectory[0].VirtualAddress;
    if ( !v7 )
    {
      *a3 = 5;
      return 0;
    }
    v8 = *(_DWORD *)((char *)&a1->e_res[4] + v7);
    v9 = *(_DWORD *)((char *)&a1->e_res[2] + v7);
    v10 = *(_DWORD *)((char *)a1->e_res + v7);
    v11 = (_DWORD *)((char *)&a1->e_magic + v7);
    v12 = (char *)a1 + v8;
    v13 = (char *)a1 + v9;
    v14 = (_DWORD *)((char *)&a1->e_magic + v10);
    v24 = v12;
    v25 = v13;
    v26 = v14;
    if ( (unsigned int)a2 >> 16 )
    {
      v15 = 0;
      v22 = 0;
      v23 = *v14;
      while ( !v23 )
      {
LABEL_20:
        v22 = ++v15;
        if ( v15 > v11[5] - 1 )
        {
          *a3 = 6;
          return 0;
        }
      }
      v16 = 0;
      v17 = v13;
      v21 = (unsigned __int16 *)v12;
      while ( 1 )
      {
        if ( *v21 == v15 )
        {
          if ( !strcmp((const char *)v3 + *v17, a2) )
            return (struct _IMAGE_DOS_HEADER *)((char *)a1 + v26[v22]);
          v3 = a1;
          v15 = v22;
        }
        ++v16;
        ++v17;
        ++v21;
        if ( v16 > v11[6] - 1 )
        {
          v12 = v24;
          v13 = v25;
          goto LABEL_20;
        }
      }
    }
    v18 = (char *)v11[4];
    v19 = 0;
    for ( i = v14; a2 != v18 || !*i; ++i )
    {
      ++v19;
      ++v18;
      if ( v19 > v11[5] - 1 )
      {
        *a3 = 6;
        return 0;
      }
    }
    result = &a1[v14[v19]];
  }
  else
  {
    *a3 = 3;
    result = 0;
  }
  return result;
}

//----- (00000310) --------------------------------------------------------
struct _IMAGE_DOS_HEADER *__cdecl GetProcAddressDirectly(struct _IMAGE_DOS_HEADER *a1, char *a2)
{
  struct _IMAGE_DOS_HEADER *v2; // ebx
  struct _IMAGE_NT_HEADERS *v3; // esi
  unsigned int v4; // edi
  DWORD v5; // ebp
  int v6; // ecx
  int v7; // esi
  int v8; // edi
  _DWORD *v9; // ebp
  char *v10; // ecx
  char *v11; // esi
  _DWORD *v12; // edi
  unsigned int v13; // eax
  unsigned int v14; // edx
  _DWORD *v15; // edi
  char *v17; // ecx
  unsigned int v18; // eax
  _DWORD *i; // edx
  unsigned __int16 *v20; // [esp+10h] [ebp-18h]
  unsigned int v21; // [esp+14h] [ebp-14h]
  int v22; // [esp+18h] [ebp-10h]
  char *v23; // [esp+1Ch] [ebp-Ch]
  char *v24; // [esp+20h] [ebp-8h]
  _DWORD *v25; // [esp+24h] [ebp-4h]

  v2 = a1;
  if ( a1->e_magic != 23117 )
    return 0;
  v3 = (struct _IMAGE_NT_HEADERS *)((char *)a1 + a1->e_lfanew);
  if ( v3->Signature != 17744 )
    return 0;
  if ( v3->FileHeader.SizeOfOptionalHeader != 224 )
    return 0;
  if ( v3->OptionalHeader.Magic != 267 )
    return 0;
  v4 = v3->OptionalHeader.DataDirectory[0].VirtualAddress;
  if ( !GetEnclosingSectionHeader(v4, (struct _IMAGE_NT_HEADERS *)((char *)a1 + a1->e_lfanew)) )
    return 0;
  GetPtrFromRVA(v4, v3, (unsigned __int8 *)a1);
  v5 = v3->OptionalHeader.DataDirectory[0].VirtualAddress;
  if ( !v5 )
    return 0;
  v6 = *(_DWORD *)((char *)&a1->e_res[4] + v5);
  v7 = *(_DWORD *)((char *)&a1->e_res[2] + v5);
  v8 = *(_DWORD *)((char *)a1->e_res + v5);
  v9 = (_DWORD *)((char *)&a1->e_magic + v5);
  v10 = (char *)a1 + v6;
  v11 = (char *)a1 + v7;
  v12 = (_DWORD *)((char *)&a1->e_magic + v8);
  v24 = v10;
  v23 = v11;
  v25 = v12;
  if ( (unsigned int)a2 >> 16 )
  {
    v13 = 0;
    v21 = 0;
    v22 = *v12;
    do
    {
      if ( v22 )
      {
        v14 = 0;
        v15 = v11;
        v20 = (unsigned __int16 *)v10;
        while ( 1 )
        {
          if ( *v20 == v13 )
          {
            if ( !strcmp((const char *)v2 + *v15, a2) )
              return (struct _IMAGE_DOS_HEADER *)((char *)a1 + v25[v21]);
            v2 = a1;
            v13 = v21;
          }
          ++v14;
          ++v15;
          ++v20;
          if ( v14 > v9[6] - 1 )
          {
            v11 = v23;
            v10 = v24;
            break;
          }
        }
      }
      v21 = ++v13;
    }
    while ( v13 <= v9[5] - 1 );
    return 0;
  }
  v17 = (char *)v9[4];
  v18 = 0;
  for ( i = v12; a2 != v17 || !*i; ++i )
  {
    ++v18;
    ++v17;
    if ( v18 > v9[5] - 1 )
      return 0;
  }
  return &a1[v12[v18]];
}

//----- (000004A0) --------------------------------------------------------
int __cdecl LoadPbDllFromMemory(void *lp, void **a2)
{
  BOOL (__stdcall *v3)(const void *, UINT_PTR); // esi
  const char *v4; // ebp
  unsigned __int16 v5; // cx
  const char *v6; // edi
  size_t v7; // esi
  void *v8; // eax
  unsigned __int16 i; // si
  char *v10; // edi
  char *v11; // esi
  int v12; // eax
  int v13; // ebp
  char *v14; // ebp
  const CHAR *v15; // esi
  HMODULE v16; // ebx
  char *v17; // edi
  FARPROC *v18; // esi
  const CHAR *v19; // eax
  int v20; // edx
  int v21; // eax
  char *v22; // edx
  char *j; // esi
  DWORD v24; // ebp
  size_t *v25; // ebx
  bool v26; // zf
  size_t v27; // eax
  unsigned int v28; // esi
  int v29; // ecx
  unsigned int v30; // edi
  unsigned int v31; // eax
  int v32; // edx
  int v33; // esi
  unsigned int v34; // ecx
  char *v35; // edi
  BOOL (__stdcall *v36)(LPVOID, SIZE_T, DWORD, PDWORD); // ebp
  int v37; // esi
  DWORD v38; // eax
  char *lpAddress; // [esp+10h] [ebp-1040h]
  int v40; // [esp+14h] [ebp-103Ch]
  int v41; // [esp+14h] [ebp-103Ch]
  unsigned __int16 v42; // [esp+14h] [ebp-103Ch]
  size_t v43; // [esp+18h] [ebp-1038h]
  DWORD v44; // [esp+18h] [ebp-1038h]
  int v45; // [esp+1Ch] [ebp-1034h]
  char *v46; // [esp+1Ch] [ebp-1034h]
  int v47; // [esp+20h] [ebp-1030h]
  int v48; // [esp+20h] [ebp-1030h]
  DWORD flOldProtect; // [esp+24h] [ebp-102Ch] BYREF
  size_t Size; // [esp+28h] [ebp-1028h]
  struct _SYSTEM_INFO SystemInfo; // [esp+2Ch] [ebp-1024h] BYREF
  char v52[4096]; // [esp+50h] [ebp-1000h] BYREF

  if ( !lp )
    return 1;
  v3 = IsBadReadPtr;
  if ( IsBadReadPtr(lp, 0x40u) || *(_WORD *)lp != 23117 )
    return 2;
  v4 = (char *)lp + *((_DWORD *)lp + 15);
  if ( v3(v4, 0xF8u) || *(_DWORD *)v4 != 17744 )
    return 3;
  if ( *((_WORD *)v4 + 10) != 224 || *((_WORD *)v4 + 12) != 267 )
    return 4;
  v5 = *((_WORD *)v4 + 3);
  if ( !v5 )
    return 5;
  v47 = 0;
  Size = (size_t)&v4[40 * v5 - (_DWORD)lp + 248];
  v43 = Size;
  v45 = 0;
  v6 = v4 + 260;
  v40 = v5;
  do
  {
    if ( v43 < *((_DWORD *)v6 + 1) + *(_DWORD *)v6 )
      v43 = *((_DWORD *)v6 + 1) + *(_DWORD *)v6;
    if ( !strcmp(v6 - 12, ".rsrc") )
      v47 = v45;
    v6 += 40;
    v26 = v40 == 1;
    ++v45;
    --v40;
  }
  while ( !v26 );
  v7 = v43;
  GetSystemInfo(&SystemInfo);
  v44 = v43 / SystemInfo.dwPageSize;
  if ( v7 % SystemInfo.dwPageSize )
    ++v44;
  v8 = VirtualAlloc(0, v44 * SystemInfo.dwPageSize, 0x1000u, 0x40u);
  *a2 = v8;
  if ( !v8 )
    return 6;
  memmove(v8, lp, Size);
  for ( i = 0; i < *((_WORD *)v4 + 3); ++i )
    memmove(
      (char *)*a2 + *(_DWORD *)&v4[40 * i + 260],
      (char *)lp + *(_DWORD *)&v4[40 * i + 268],
      *(_DWORD *)&v4[40 * i + 264]);
  v10 = (char *)*a2;
  lpAddress = v10;
  v11 = &v10[*((_DWORD *)v10 + 15)];
  v46 = v11;
  if ( v47 && IsNT() )
  {
    v12 = (int)&v11[40 * v47 + 248];
    *(_DWORD *)(v12 + 12) = (char *)lp + *(_DWORD *)&v11[40 * v47 + 260];
    *(_DWORD *)(v12 + 20) = (char *)lp + *(_DWORD *)&v11[40 * v47 + 268];
  }
  v13 = *((_DWORD *)v11 + 32);
  if ( !v13 )
  {
    VirtualFree(v10, 0, 0x8000u);
    return 7;
  }
  v14 = &v10[v13];
  v41 = 13;
  while ( 1 )
  {
    if ( !*((_DWORD *)v14 + 1) && !*((_DWORD *)v14 + 3) )
    {
      v20 = *((_DWORD *)v11 + 40);
      if ( v20 )
      {
        v21 = *(_DWORD *)&v10[v20];
        v22 = &v10[v20];
        if ( v21 )
        {
          do
          {
            for ( j = v22 + 8; j < &v22[*((_DWORD *)v22 + 1)]; j += 2 )
            {
              if ( (*(_WORD *)j & 0xF000) == 12288 )
              {
                *(_DWORD *)&lpAddress[*(_DWORD *)v22 + (*(_WORD *)j & 0xFFF)] += &lpAddress[-*((_DWORD *)v46 + 13)];
              }
              else if ( (*(_WORD *)j & 0xF000) != 0 )
              {
                VirtualFree(lpAddress, 0, 0x8000u);
                return 12;
              }
            }
            v22 += *((_DWORD *)v22 + 1);
          }
          while ( *(_DWORD *)v22 );
          v11 = v46;
        }
      }
      v24 = SystemInfo.dwPageSize;
      memset(v52, 0, sizeof(v52));
      v48 = 0;
      v42 = *((_WORD *)v11 + 3);
      v25 = (size_t *)(v11 + 264);
      v26 = v42 == 0;
      do
      {
        if ( v26 )
        {
          v27 = Size;
          v28 = 0;
          v29 = 1610612736;
        }
        else
        {
          v28 = *(v25 - 1);
          v27 = *v25;
          v29 = v25[5];
        }
        v30 = (v27 + v28 - 1) / v24;
        v31 = v28 / v24;
        if ( v28 / v24 <= v30 )
        {
          v32 = v29 & 0x20000000;
          v33 = v29 & 0x40000000;
          v34 = v29 & 0x80000000;
          do
          {
            if ( v32 )
              v52[v31] |= 1u;
            if ( v33 )
              v52[v31] |= 2u;
            if ( v34 )
              v52[v31] |= 4u;
            ++v31;
          }
          while ( v31 <= v30 );
        }
        v25 += 10;
        v26 = (_WORD)v48++ + 1 == v42;
      }
      while ( (unsigned __int16)v48 <= v42 );
      v35 = lpAddress;
      v36 = VirtualProtect;
      v37 = 0;
      while ( 1 )
      {
        switch ( v52[v37] )
        {
          case 2:
            v38 = 2;
            break;
          case 3:
            v38 = 32;
            break;
          case 6:
            v38 = 4;
            break;
          default:
            flOldProtect = 64;
            goto LABEL_76;
        }
        flOldProtect = v38;
        if ( !v36(v35, SystemInfo.dwPageSize, v38, &flOldProtect) )
        {
          VirtualFree(lpAddress, 0, 0x8000u);
          return 13;
        }
LABEL_76:
        v35 += SystemInfo.dwPageSize;
        if ( ++v37 > v44 )
        {
          ((void (__stdcall *)(char *, int, _DWORD))&lpAddress[*((_DWORD *)v46 + 10)])(lpAddress, 1, 0);
          return 0;
        }
      }
    }
    v15 = &lpAddress[*((_DWORD *)v14 + 3)];
    v16 = GetModuleHandleA(v15);
    if ( !v16 )
      v16 = LoadLibraryA(v15);
    ++v41;
    if ( !v16 )
    {
      VirtualFree(lpAddress, 0, 0x8000u);
      return v41;
    }
    v17 = &lpAddress[*(_DWORD *)v14];
    v18 = (FARPROC *)&lpAddress[*((_DWORD *)v14 + 4)];
    v19 = *(const CHAR **)v17;
    if ( *(_DWORD *)v17 )
      break;
LABEL_40:
    v10 = lpAddress;
    v11 = v46;
    v14 += 20;
  }
  while ( 1 )
  {
    v19 = (int)v19 >= 0 ? &lpAddress[(_DWORD)v19 + 2] : (unsigned __int16)v19;
    *v18 = GetProcAddress(v16, v19);
    if ( !v18 )
      break;
    v19 = (const CHAR *)*((_DWORD *)v17 + 1);
    v17 += 4;
    ++v18;
    if ( !v19 )
      goto LABEL_40;
  }
  VirtualFree(lpAddress, 0, 0x8000u);
  return 11;
}
// 569: conditional instruction was optimized away because of 'cx.2!=0'

//----- (000009E8) --------------------------------------------------------
BOOL __cdecl UnloadPbDllFromMemory(struct _IMAGE_DOS_HEADER *lpAddress)
{
  ((void (__stdcall *)(struct _IMAGE_DOS_HEADER *, _DWORD, _DWORD))((char *)lpAddress
                                                                  + *(_DWORD *)((char *)lpAddress->e_res2
                                                                              + lpAddress->e_lfanew)))(
    lpAddress,
    0,
    0);
  return VirtualFree(lpAddress, 0, 0x8000u);
}

//----- (00000A18) --------------------------------------------------------
unsigned int __cdecl MakeAHPe(void *lp, char *a2, int *a3)
{
  unsigned int result; // eax
  BOOL (__stdcall *v4)(const void *, UINT_PTR); // edi
  struct _IMAGE_NT_HEADERS *v5; // ebx
  unsigned int v6; // eax
  __time32_t v7; // edi
  unsigned int v8; // edi
  struct _IMAGE_SECTION_HEADER *v9; // eax
  int v10; // esi
  _DWORD *v11; // edi
  int *v12; // edi
  int v13; // eax
  unsigned int v14; // edi
  struct _IMAGE_SECTION_HEADER *v15; // eax
  int v16; // ecx
  _DWORD *v17; // edi
  char *v18; // esi
  _DWORD *v19; // edx
  int v20; // ecx
  char *v21; // esi
  WORD v22; // bp
  _DWORD *v23; // esi
  _DWORD *v24; // eax
  char *v25; // ecx
  size_t v26; // edi
  _DWORD *v27; // [esp+10h] [ebp-8h]
  char *v28; // [esp+10h] [ebp-8h]
  char *v29; // [esp+14h] [ebp-4h]
  int i; // [esp+14h] [ebp-4h]

  if ( !lp )
    return 1;
  v4 = IsBadReadPtr;
  v29 = a2 + 30;
  if ( IsBadReadPtr(lp, 0x40u) || *(_WORD *)lp != 23117 )
    return 2;
  v5 = (struct _IMAGE_NT_HEADERS *)((char *)lp + *((_DWORD *)lp + 15));
  if ( v4(v5, 0xF8u) || v5->Signature != 17744 )
    return 3;
  if ( v5->FileHeader.SizeOfOptionalHeader != 224 || v5->OptionalHeader.Magic != 267 )
    return 4;
  if ( !v5->FileHeader.NumberOfSections )
    return 5;
  v6 = time(0);
  srand(v6);
  v7 = time(0);
  *(_DWORD *)a2 = 30864 * (rand() * v7 / 0x7890u) + 31974;
  *((_DWORD *)a2 + 1) = v5->OptionalHeader.SizeOfImage;
  *((_WORD *)a2 + 4) = v5->FileHeader.NumberOfSections;
  *(_DWORD *)(a2 + 10) = v5->OptionalHeader.ImageBase;
  *(_DWORD *)(a2 + 22) = v5->OptionalHeader.AddressOfEntryPoint;
  *(_DWORD *)(a2 + 18) = v5->OptionalHeader.DataDirectory[5].VirtualAddress;
  v8 = v5->OptionalHeader.DataDirectory[1].VirtualAddress;
  *(_DWORD *)(a2 + 14) = v8;
  v9 = GetEnclosingSectionHeader(v8, v5);
  v10 = v9->VirtualAddress - v9->PointerToRawData;
  if ( !v8 )
    return 8;
  v11 = (char *)lp + v8 - v10;
  v27 = v11;
  while ( v11[1] || v11[3] )
  {
    if ( AHPeEncryptStr((char *)lp + v11[3] - v10) )
      return 9;
    v12 = (int *)((char *)lp + *v11 - v10);
    v13 = *v12;
    if ( *v12 )
    {
      while ( v13 < 0 || !AHPeEncryptStr((char *)lp + v13 - v10 + 2) )
      {
        v13 = v12[1];
        ++v12;
        if ( !v13 )
          goto LABEL_20;
      }
      return 10;
    }
LABEL_20:
    v27 += 5;
    v11 = v27;
  }
  v14 = v5->OptionalHeader.DataDirectory[0].VirtualAddress;
  if ( !v14 )
    return 11;
  v15 = GetEnclosingSectionHeader(v14, v5);
  v16 = v15->VirtualAddress - v15->PointerToRawData;
  v17 = (char *)lp + v14 - v16;
  v18 = (char *)lp + v17[9] - v16;
  v19 = (char *)lp + v17[7] - v16;
  v20 = 0;
  v28 = v18;
  if ( v17[5] )
  {
    while ( *v19 )
    {
      *(_DWORD *)v29 = *(unsigned __int16 *)&v18[2 * (unsigned __int16)v20];
      *((_DWORD *)v29 + 1) = v19[(unsigned __int16)v20];
      v21 = v29 + 8;
      ++v20;
      v29 += 8;
      if ( (unsigned int)(unsigned __int16)v20 >= v17[5] )
        goto LABEL_33;
      v18 = v28;
    }
    result = 12;
  }
  else
  {
    v21 = a2 + 30;
LABEL_33:
    v22 = 0;
    *(_DWORD *)(a2 + 26) = v17[5];
    for ( i = (int)&v5->OptionalHeader + v5->FileHeader.SizeOfOptionalHeader; v22 < v5->FileHeader.NumberOfSections; ++v22 )
    {
      v23 = v21 + 12;
      v24 = (_DWORD *)(i + 40 * v22);
      v25 = (char *)lp + v24[5];
      v26 = v24[4];
      *(v23 - 3) = v24[3];
      *(v23 - 1) = v26;
      *(v23 - 2) = v24[9];
      memmove(v23, v25, v26);
      v21 = (char *)v23 + v26;
    }
    *a3 = v21 - a2;
    result = 0;
  }
  return result;
}

//----- (00000D08) --------------------------------------------------------
int __cdecl LoadAHPe(void *a1, void **a2, struct AHPE_ExportFunction_T *a3)
{
  char *v3; // edi
  int result; // eax
  unsigned __int16 v5; // ax
  unsigned int v6; // eax
  unsigned int v7; // eax
  char *v8; // esi
  DWORD v9; // ebp
  void *v10; // eax
  void **v11; // ecx
  int v12; // edx
  int v13; // eax
  int v14; // eax
  char *v15; // ebx
  int v16; // edx
  size_t v17; // ebp
  char *v18; // esi
  struct AHPE_ExportFunction_T *v19; // ebp
  char *v20; // esi
  int *v21; // ebp
  int v22; // eax
  FARPROC *v23; // esi
  char *v24; // ebx
  unsigned int v25; // kr08_4
  char *v26; // edi
  int v27; // edx
  int v28; // eax
  char *v29; // edx
  char *i; // esi
  int v31; // [esp+10h] [ebp-30h]
  HMODULE hModule; // [esp+14h] [ebp-2Ch]
  char *v33; // [esp+18h] [ebp-28h]
  struct _SYSTEM_INFO SystemInfo; // [esp+1Ch] [ebp-24h] BYREF
  __int16 v35; // [esp+4Ch] [ebp+Ch]
  struct AHPE_ExportFunction_T *v36; // [esp+4Ch] [ebp+Ch]

  v3 = (char *)a1;
  v31 = 0;
  if ( !a1 )
    return 1;
  if ( *(_DWORD *)a1 % 0x7890u != 1110 )
    return 2;
  v5 = *((_WORD *)a1 + 4);
  if ( !v5 || v5 > 0xAu )
    return 3;
  if ( *((_DWORD *)a1 + 1) > 0x4C4B40u )
    return 4;
  v6 = *(_DWORD *)((char *)a1 + 14);
  if ( !v6 || v6 > 0x8FFFFFFF )
    return 5;
  v7 = *(_DWORD *)((char *)a1 + 22);
  if ( !v7 || v7 > 0x8FFFFFFF )
    return 6;
  v8 = (char *)a1 + 8 * *(_DWORD *)((char *)a1 + 26) + 30;
  GetSystemInfo(&SystemInfo);
  v9 = *((_DWORD *)a1 + 1) / SystemInfo.dwPageSize;
  if ( *((_DWORD *)a1 + 1) % SystemInfo.dwPageSize )
    ++v9;
  v10 = VirtualAlloc(0, v9 * SystemInfo.dwPageSize, 0x1000u, 0x40u);
  v11 = a2;
  *a2 = v10;
  if ( !v10 )
    return 7;
  v12 = 0;
  if ( *(_DWORD *)((char *)a1 + 26) )
  {
    v13 = 0;
    do
    {
      v14 = 8 * v13;
      *(_DWORD *)((char *)a3 + v14) = *(_DWORD *)((char *)a1 + v14 + 30);
      ++v12;
      *(_DWORD *)((char *)a3 + v14 + 4) = (char *)*a2 + *(_DWORD *)((char *)a1 + v14 + 34);
      v13 = (unsigned __int16)v12;
    }
    while ( (unsigned int)(unsigned __int16)v12 < *(_DWORD *)((char *)a1 + 26) );
  }
  v15 = (char *)*a2;
  v33 = v15;
  v35 = 0;
  *(_DWORD *)(v15 + 22) = *(_DWORD *)((char *)a1 + 22);
  if ( *((_WORD *)a1 + 4) )
  {
    while ( 1 )
    {
      v16 = *(_DWORD *)v8;
      v17 = *((_DWORD *)v8 + 2);
      v18 = v8 + 12;
      memmove((char *)*v11 + v16, v18, v17);
      v8 = &v18[v17];
      if ( (unsigned __int16)++v35 >= *((_WORD *)a1 + 4) )
        break;
      v11 = a2;
    }
  }
  v19 = (struct AHPE_ExportFunction_T *)&v15[*(_DWORD *)((char *)a1 + 14)];
  v36 = v19;
  while ( *((_DWORD *)v19 + 1) || *((_DWORD *)v19 + 3) )
  {
    v20 = &v15[*((_DWORD *)v19 + 3)];
    if ( AHPeDecryptStr(v20) )
    {
      v31 = 8;
      goto LABEL_51;
    }
    hModule = GetModuleHandleA(v20);
    if ( !hModule )
    {
      hModule = LoadLibraryA(v20);
      if ( !hModule )
      {
        v31 = 9;
        goto LABEL_51;
      }
    }
    memset(v20, 0, strlen(v20));
    v21 = (int *)&v15[*(_DWORD *)v19];
    v22 = *v21;
    v23 = (FARPROC *)&v15[*((_DWORD *)v36 + 4)];
    if ( *v21 )
    {
      while ( 1 )
      {
        if ( v22 >= 0 )
        {
          v24 = &v15[v22 + 2];
          if ( AHPeDecryptStr(v24) )
            goto LABEL_51;
          *v23 = GetProcAddress(hModule, v24);
          v25 = strlen(v24) + 1;
          v26 = v24;
          v15 = v33;
          memset(v26, 0, v25 - 1);
        }
        else
        {
          *v23 = GetProcAddress(hModule, (LPCSTR)(unsigned __int16)v22);
        }
        if ( !v23 )
          break;
        v22 = v21[1];
        ++v21;
        ++v23;
        if ( !v22 )
          goto LABEL_37;
      }
      v31 = 10;
LABEL_51:
      VirtualFree(*a2, 0, 0x8000u);
      result = v31;
      *a2 = 0;
      return result;
    }
LABEL_37:
    v3 = (char *)a1;
    v36 = (struct AHPE_ExportFunction_T *)((char *)v36 + 20);
    v19 = v36;
  }
  v27 = *(_DWORD *)(v3 + 18);
  if ( v27 )
  {
    v28 = *(_DWORD *)&v15[v27];
    v29 = &v15[v27];
    if ( v28 )
    {
      do
      {
        for ( i = v29 + 8; i < &v29[*((_DWORD *)v29 + 1)]; i += 2 )
        {
          if ( (*(_WORD *)i & 0xF000) == 12288 )
          {
            *(_DWORD *)&v15[*(_DWORD *)v29 + (*(_WORD *)i & 0xFFF)] += &v15[-*(_DWORD *)(v3 + 10)];
          }
          else if ( (*(_WORD *)i & 0xF000) != 0 )
          {
            v31 = 11;
            goto LABEL_51;
          }
        }
        v29 += *((_DWORD *)v29 + 1);
      }
      while ( *(_DWORD *)v29 );
    }
  }
  ((void (__stdcall *)(char *, int, _DWORD))&v15[*(_DWORD *)(v3 + 22)])(v15, 1, 0);
  return 0;
}

//----- (00001078) --------------------------------------------------------
BOOL __cdecl UnloadAHPe(void *lpAddress)
{
  ((void (__stdcall *)(void *, _DWORD, _DWORD))((char *)lpAddress + *(_DWORD *)((char *)lpAddress + 22)))(
    lpAddress,
    0,
    0);
  return VirtualFree(lpAddress, 0, 0x8000u);
}

//----- (000010A8) --------------------------------------------------------
unsigned int __cdecl ReadFileToBuff(LPCSTR lpFileName, void **a2)
{
  unsigned int result; // eax
  void *v3; // esi
  const CHAR *v4; // edi
  void *v5; // eax
  void **v6; // ebx

  result = (unsigned int)CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0, 0);
  v3 = (void *)result;
  if ( result != -1 )
  {
    v4 = (const CHAR *)GetFileSize((HANDLE)result, 0);
    lpFileName = 0;
    v5 = operator new((unsigned int)v4);
    v6 = a2;
    *a2 = v5;
    if ( v5 )
    {
      if ( ReadFile(v3, v5, (DWORD)v4, (LPDWORD)&lpFileName, 0) )
      {
        CloseHandle(v3);
        if ( v4 == lpFileName )
        {
          result = (unsigned int)v4;
        }
        else
        {
          operator delete(*v6);
          *v6 = 0;
          result = -1;
        }
      }
      else
      {
        operator delete(*v6);
        *v6 = 0;
        CloseHandle(v3);
        result = -1;
      }
    }
    else
    {
      CloseHandle(v3);
      result = -1;
    }
  }
  return result;
}

//----- (00001168) --------------------------------------------------------
BOOL __cdecl IsNT()
{
  return (GetVersion() & 0x80000000) == 0;
}

//----- (00001178) --------------------------------------------------------
unsigned int __cdecl AHPeEncryptStr(char *a1)
{
  char *v1; // edx
  int v2; // esi
  int v3; // ecx
  char v4; // al
  char v5; // al

  v1 = a1;
  v2 = 0;
  v3 = 7;
  v4 = *a1;
  if ( !*a1 )
    return 0;
  while ( ++v2 <= 260 )
  {
    v5 = v3 + v4;
    v3 += 2;
    *v1++ = v5;
    if ( v3 > 17 )
      v3 = 7;
    v4 = *v1;
    if ( !*v1 )
      return 0;
  }
  return 1;
}

//----- (000011B8) --------------------------------------------------------
unsigned int __cdecl AHPeDecryptStr(char *a1)
{
  char *v1; // edx
  int v2; // esi
  int v3; // ecx
  char v4; // al
  char v5; // al

  v1 = a1;
  v2 = 0;
  v3 = 7;
  v4 = *a1;
  if ( !*a1 )
    return 0;
  while ( ++v2 <= 260 )
  {
    v5 = v4 - v3;
    v3 += 2;
    *v1++ = v5;
    if ( v3 > 17 )
      v3 = 7;
    v4 = *v1;
    if ( !*v1 )
      return 0;
  }
  return 1;
}

// nfuncs=39 queued=14 decompiled=14 lumina nreq=0 worse=0 better=0
// ALL OK, 14 function(s) have been successfully decompiled
